
// Created by mousymous at March 9 and finished at March 10


#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>

#define PORT 1000

struct Var{

  int server_socket;
  int client_socket;

};

// Function for configuring IP address and Port, asks for pointer to struct sockaddr_in Parameter
void _conf_address(struct sockaddr_in * address){
  address -> sin_family = AF_INET;         // Specify the address familly to IPv4 
  address -> sin_port = htons(PORT);       // Specify Port Number for the socket for listening
  address -> sin_addr.s_addr = INADDR_ANY; // Specify the IP address that will listen for (Will listen to any)
}

// Function for creating a socket  
void _create_socket(struct Var * var) {

  // The if statements check if the socket() functions returns p-1 if it is then it means it fails at creating a socket
  // the return value of socket() is passed to pointer to int, to the int variable from the Var structure
  // Socket uses TCP Protocol
  if ( (var -> server_socket = socket(PF_INET, SOCK_STREAM, 0)) < 0){
    fprintf(stderr, "Error at building socket...\n"); exit(-1);
  }
  
}

// Binds the Socket to the Port to Convert it into a Full Address for communication, the parameter asks for Pointer to Structure of Var and sockaddr_in
void _bind_socket(struct Var * var, struct sockaddr_in * address){
  
  // if statement just checks for the return value of bind() function, if it returns -1 then it failed else then success
  if ( bind(var -> server_socket, (struct sockaddr*)&*address, sizeof(*address)) < 0 ){ 
    fprintf(stderr, "Binding Error...\n");
    exit(-1);
  }
}

// A Function for Listening for incoming request connection, parameter is a pointer to structure Var where the socket file descriptor is located
void _listen_socket(struct Var * var){

  // if statements checks for return value of function listen(), if returns -1 then fail, else then success
  if ( listen(var -> server_socket, 10) < 0){
    fprintf(stderr, "Error at listening...\n");
    exit(-1);
  }
}

// Accepts Requesting Connection from clients, Parameter of pointer to structure of Var and Sockaddr_in
void _accept_socket(struct Var * var, struct sockaddr_in * address){

  // Converts the address structure to it's on size for the third argument of accept() function, then placing the size to variable address_len
  socklen_t address_len = sizeof(&address);

  // An if statement for error checking like others
  // the accept() function returns an int value for a new socket to identify the accepted client connection, it is written this way by the
  // developer of the accept() function so the server side can deal with multiple client, the return int value is passed to the
  // client_socket variable sitting inside the Var structure using the pointer to Var structure to access it.
  if ( (var -> client_socket = accept(var -> server_socket, (struct sockaddr*)&*address, &address_len)) < 0 ) {
    fprintf(stderr, "Error Connection...\n");
    exit(-1);
  }

  // If connection success then it prints Connection has been Established
  fprintf(stdout, "\n\nConnection Established...\n\n");
}


// A Function used for sending a message to the client that has succesfully established a connection, Parameter is pointer to structure of Var
void _send_commands(struct Var * var){

  char buffer[1024]; // Variable for containing the String

  while (1) { // Loop
    printf("command: "); fgets(buffer, sizeof(buffer), stdin); // Input message
    send(var -> client_socket, buffer, sizeof(buffer), 0);  // Send message to client throught the new created socket by accept() function
  }
}


// Main Function
int main(int argv, char * argc[]) {

  struct sockaddr_in address;
  struct Var var;

  // Calls all the function by Order
  _conf_address(&address);
  _create_socket(&var);
  _bind_socket(&var, &address);
  _listen_socket(&var);
  _accept_socket(&var, &address);
  _send_commands(&var);

  // Close the Socket Afterwards
  close(var.server_socket);
  return 0;
}

